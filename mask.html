<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shutter Mask | 暗記マーカー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        #canvasContainer { touch-action: none; position: relative; display: inline-block; }
        canvas { max-width: 100%; height: auto; border-radius: 8px; }
        .mode-btn.active { background-color: #6366f1; color: white; border-color: #6366f1; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen flex flex-col">

    <header class="p-4 flex justify-between items-center bg-slate-800 border-b border-slate-700">
        <h1 class="text-xl font-black italic tracking-tighter">SHUTTER <span class="text-indigo-400">MASK</span></h1>
        <div class="flex gap-2">
            <button onclick="clearMasks()" class="text-xs bg-slate-700 px-3 py-2 rounded-lg font-bold">全消去</button>
            <label class="bg-indigo-600 px-4 py-2 rounded-lg font-bold text-sm cursor-pointer hover:bg-indigo-500">
                <i class="fas fa-camera mr-1"></i> 画像を選択
                <input type="file" id="imageInput" accept="image/*" class="hidden" onchange="handleImage(this)">
            </label>
        </div>
    </header>

    <div class="flex-1 overflow-auto p-4 flex justify-center items-start">
        <div id="canvasContainer">
            <canvas id="mainCanvas"></canvas>
            <div id="hintMsg" class="absolute inset-0 flex items-center justify-center text-slate-500 pointer-events-none">
                画像を選択してください
            </div>
        </div>
    </div>

    <footer class="p-6 bg-slate-800 border-t border-slate-700 flex justify-center gap-4">
        <button id="btnEdit" onclick="setMode('edit')" class="mode-btn active border-2 border-slate-600 px-6 py-3 rounded-2xl font-black transition-all flex items-center gap-2">
            <i class="fas fa-pen"></i> マスク作成
        </button>
        <button id="btnTest" onclick="setMode('test')" class="mode-btn border-2 border-slate-600 px-6 py-3 rounded-2xl font-black transition-all flex items-center gap-2">
            <i class="fas fa-eye-slash"></i> テスト
        </button>
    </footer>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let img = new Image();
        let masks = [];
        let isDrawing = false;
        let startX, startY;
        let currentMode = 'edit'; // 'edit' or 'test'

        // 画像の読み込み
        function handleImage(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    document.getElementById('hintMsg').classList.add('hidden');
                    draw();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 描画メインループ
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            masks.forEach((m, idx) => {
                if (currentMode === 'test') {
                    // テストモード：不透明なマスク
                    ctx.fillStyle = m.revealed ? 'rgba(99, 102, 241, 0.2)' : '#1e293b';
                    ctx.fillRect(m.x, m.y, m.w, m.h);
                    if (!m.revealed) {
                        ctx.strokeStyle = '#334155';
                        ctx.strokeRect(m.x, m.y, m.w, m.h);
                    }
                } else {
                    // 編集モード：半透明のガイド
                    ctx.fillStyle = 'rgba(244, 63, 94, 0.4)';
                    ctx.fillRect(m.x, m.y, m.w, m.h);
                    ctx.strokeStyle = '#f43f5e';
                    ctx.strokeRect(m.x, m.y, m.w, m.h);
                }
            });
        }

        // マウス・タッチイベント
        canvas.addEventListener('mousedown', startAction);
        canvas.addEventListener('mousemove', moveAction);
        canvas.addEventListener('mouseup', endAction);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startAction(e.touches[0]); });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); moveAction(e.touches[0]); });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); endAction(); });

        function startAction(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (currentMode === 'test') {
                // テストモード：クリックしたマスクをめくる
                masks.forEach(m => {
                    if (x > m.x && x < m.x + m.w && y > m.y && y < m.y + m.h) {
                        m.revealed = !m.revealed;
                    }
                });
                draw();
            } else {
                // 編集モード：マスク作成開始
                isDrawing = true;
                startX = x;
                startY = y;
            }
        }

        function moveAction(e) {
            if (!isDrawing || currentMode !== 'edit') return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            draw();
            ctx.fillStyle = 'rgba(244, 63, 94, 0.2)';
            ctx.fillRect(startX, startY, x - startX, y - startY);
        }

        function endAction(e) {
            if (!isDrawing) return;
            isDrawing = false;
            // 座標を計算して保存
            const rect = canvas.getBoundingClientRect();
            // イベントがmouseupの場合、座標を取得
            const x = (event.clientX - rect.left) * (canvas.width / rect.width);
            const y = (event.clientY - rect.top) * (canvas.height / rect.height);
            
            masks.push({
                x: Math.min(startX, x),
                y: Math.min(startY, y),
                w: Math.abs(x - startX),
                h: Math.abs(y - startY),
                revealed: false
            });
            draw();
        }

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btnEdit').classList.toggle('active', mode === 'edit');
            document.getElementById('btnTest').classList.toggle('active', mode === 'test');
            if (mode === 'test') {
                masks.forEach(m => m.revealed = false);
            }
            draw();
        }

        function clearMasks() {
            if (confirm("すべてのマスクを消去しますか？")) {
                masks = [];
                draw();
            }
        }
    </script>
</body>
</html>
